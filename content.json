{"pages":[{"title":"关于我","text":"我叫王凯（Kevin）是 PHP 开发大军中的一员，同时也非常喜欢 C++ 开发。这里是我的个人博客，记录平时的学习生活，欢迎大家阅览。 联系我QQ: 3056782267Email: kevinken774@gmail.com","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"友链","text":"大佬乔醬的博客涂峻嘉的博客","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"AT&T 汇编","text":"AT&amp;T 汇编介绍","link":"/2018/10/05/atas/"},{"title":"设计模式开篇","text":"设计模式开篇 设计模式是什么？为什么需要设计模式？设计模式的作用？设计模式的八大原则。依赖倒置原则（DIP）开闭原则（OCP）设计模式之模板模式","link":"/2019/07/06/design-pattern/"},{"title":"文件I0","text":"UNIX 环境高级编程第三章本章描述了 UNIX 文件I/O的知识 打开一个文件或设备123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags, mode_t mode);int openat(int fd, const char *pathname, int flags, mode_t mode); flags: O_RDONLY, O_WRONLY, O_RDWR 个有且有一个 可选: O_APPEND 每次写时都追加到文件的尾端 O_CREAT 若此文件不存在则创建它 O_TRUNC 若此文件存在，而且为只写或读-写成功打开，则将其长度截取为0 O_SYNC 等待写完成(数据和属性) fd 参数把 open 和 openat 函数区分开来，共有三种可能性。 1). path 参数指定的绝对路径名，在这种情况下，fd 参数被忽略，openat 函数相当于open函数。 2). path 参数指定的是相对路径名，fd 参数指出了相对路径名在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。 3). path 参数指定了相对路径名，fd 参数具有特殊值 AT_FDCWD。在这种情况下，路径名在当前工作中获取，openat 函数在操作上与 open 函数类似。 创建一个新文件123#include &lt;fcntl.h&gt;int creat(const char *path, mode_t mode); Note: 此函数等价于: open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); 关闭一个打开的文件123#include &lt;unistd.h&gt;int close(int fd); 设置文件偏移量123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 对参数 offset 的解释与参数 whence 有关 1). 若 whence 是 SEEK_SET, 则将该文件的偏移量设置为距文件开始处 offset 个字节 2). 若 whence 是 SEEK_CUR, 则将该文件的偏移量设置为其当前值加 offset，offset 可为正或负 3). 若 whence 是 SEEK_END, 则将该文件的偏移量设置为文件长度加 offset，offset 可正可负若 lseek 成功执行，则返回新的文件偏移量。如果文件描述符指向的是一个管道，FIFO 或网络套接字，则 lseek 返回-1,并将 errno 设置为 ESPIPElseek – l 指的是 long (长整型) 读取数据123#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); 返回值: 1). 若读取成功则返回读到的字节数 2). 若已到文件尾，返回0 3). 若出错，返回-1 写数据123#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes); 返回值: 1). 若写入失败则返回已写的字节数 2). 若出错，返回-1 原子读写操作12345#include &lt;unistd.h&gt;ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); 返回值: 与 open, write 系统调用的返回值相同 函数 dup 和 dup212345#include &lt;unistd.h&gt;int dup(int oldfd);int dup2(int oldfd, int newfd); 返回值: 1). 若成功，则返回新的文件描述符 2). 若出错，返回-1 函数 sync, fsync, fdatasync1234567#include &lt;unistd.h&gt;int fsync(int fd);int fdatasync(int fd);void sync(void); 返回值(fsync, fdatasync): 1). 若成功，返回0 2). 若出错，返回-1 函数 fcntl123#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* int arg */); 返回值: 1). 若成功，则依赖于 cmd 2). 若出错，返回-1fcntl 函数有以下5种功能: 1). 复制一个已有的描述符(cmd = F_DUPFD 或 F_DUPFD_CLOEXEC) 2). 获取/设置文件描述符标志(cmd = F_GETFD 或 F_SETFD) 3). 获取/设置文件状态标志(cmd = F_GETFL 或 F_SETFL) 4). 获取/设置异步 I/O 所有权(cmd = F_GETOWN 或 F_SETOWN) 5). 获取/设置记录锁(cmd = F_GETLK, F_SETLK 或 F_SETLKW) 函数 ioctl123#include &lt;sys/ioctl.h&gt;int ioctl(int fd, unsigned long request, ...); 返回值: 1). 若出错，返回-1 2). 若成功，返回其他值","link":"/2018/09/06/file-io/"},{"title":"文件和目录","text":"UNIX 环境高级编程第三章本章描述了 UNIX 文件系统的其他特性和文件的性质 函数 stat, fstat, fstatat 和 lstat12345678#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *__restrict pathname, struct stat *__restrict buf);int fstat(int fd, struct stat *buf);int lstat(const char *__restrict pathname, struct stat *__restrict buf);int fstatat(int fd, const char *__restrict pathname, struct stat *__restrict buf); 返回值(四个函数): 1). 若成功，返回0 2). 若出错，返回-1 stat 结构体123456789101112131415struct stat { mode_t st_mode; /* file type &amp; mode (permissions) */ ino_t st_ino; dev_t st_dev; dev_t st_rdev; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; off_t st_size; struct timespec st_atime; struct timespec st_mtime; struct timespec st_ctime; blksize_t st_blksize; blkcnt_t st_blocks;}; 文件类型 普通文件(regular file) 目录文件(directory file) 块特殊文件(block special file) 字符特殊文件(character special file) FIFO 套接字(socket) 符号链接(symbolic link) 文件类型信息包含在 stat 结构中的 st_mode 成员中。","link":"/2018/10/06/file/"},{"title":"git命令学习","text":"积累平时使用到的Git命令常用： 设置远程库 推送时设置上游版本 查看分支的上游 回退版本库 拉取远程代码并rebase 设置远程库1git remote add 仓库名 仓库地址 推送时设置上游例如想要设置推送到origin远程库的master分支 123git push --set-upstream origin master# 或者使用下列命令git push -u origin master 查看分支的上游12# 显示分支所在的远程库git config --get branch.master.remote 回退版本库123456# 回退版本库，暂存库（--mixed为默认参数，即不加任何参数时）git reset --mixed commit_id# 回退版本库git reset --soft commit_id# 回退版本库，暂存库，工作区（会更改本地源代码，需谨慎操作）git reset --mixed commit_id 拉取远程代码并rebase12# 加入--rebase参数会将本地的提交整理成历史与远程master合并git pull --rebase origin master","link":"/2019/07/13/git-command/"},{"title":"Git 拒绝合并无关的历史","text":"Git在pull时因为历史不同无法合并 错误情况本地初始化的项目和 github 等远程仓库中的版本不一致，倒是无法提交代码 12git pull origin masterfatal: 拒绝合并无关的历史 解决方案在pull时添加–allow-unrelated-histories参数即可 12git pull origin master --allow-unrelated-histories合并成功","link":"/2019/07/13/git-fatal-merge-unrelated-histories/"},{"title":"Linux服务管理","text":"Debian系列发行版下的服务管理 服务的自启动删除一个服务如果想要手动的完全禁用某个服务，需要删除在”/etc/rcX.d”中的该服务链接。若使用update-rc.d，会比较简单，如下： 1update-rc.d -f servername remove 参数-f是强制删除符号链接，即使”/etc/init.d/服务”仍然存在。这个命令仅仅禁止该服务，直到该服务被升级。如果想在服务升级后仍然保持被禁用。应该执行如下的命令： 1update-rc.d servername stop 80 0 1 2 3 4 5 6 . 增加一个服务如果想重新添加这个服务并让它开机自动执行，执行以下命令： 1update-rc.d servername defaults 并且可以指定该服务的启动顺序： 1update-rc.d servername defaults 90 还可以更详细的控制start与kill顺序： 1update-rc.d servername defaults 20 80 其中前面的20是start时的运行顺序级别，80为kill时的级别。也可以写成： 1update-rc.d servername start 20 2 3 4 5 . stop 80 0 1 6 . 其中0～6为运行级别。 update-rc.d命令不仅适用Linux服务，编写的脚本同样可以用这个命令设为开机自动运行 Systemd方式管理在较新的内核中，其使用了 Systemd，不再用init。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。因此，相关的服务管理也由Systemd负责。 设置开机启动服务1systemctl enable servername 关闭开机启动服务1systemctl disable servername 启动服务1systemctl start servername 关闭服务1systemctl stop servername 重启服务1systemctl restart servername 服务的手动管理启动一个服务1service servername start 关闭一个服务1service servername stop 查看一个服务的状态1service servername status","link":"/2019/07/13/linux-service/"},{"title":"mcu","text":"Linux下的单片机开发 Linux下的单片机开发环境准备 编译器：sdcc二进制转换：packihx串口驱动：python(3)-serial烧录软件：stcflash.py","link":"/2019/07/04/mcu/"},{"title":"XWINDOW 中 WINDOWID 的获取","text":"XWINDOW 下获取 WINDOWID 原文链接：https://blog.csdn.net/superkeep/article/details/88948634 linux下的脚本123456789101112131415161718192021222324#!/bin/bash#方法一xprop -root | grep \"_NET_ACTIVE_WINDOW(WINDOW)\"| cut -d ' ' -f 5#方法二xwininfo -name ShowAnimationProject | grep \"Window id\"| cut -d \" \" -f 4#方法三findpid=$1 known_windows=$(xwininfo -root -children|sed -e 's/^ *//'|grep -E \"^0x\"|awk '{ print $1 }') for id in ${known_windows}do xp=$(xprop -id $id _NET_WM_PID) if test $? -eq 0; then pid=$(xprop -id $id _NET_WM_PID|cut -d'=' -f2|tr -d ' ') if test \"x${pid}\" = x${findpid} then echo \"Windows Id: $id\" fi fidone 通过代码方式获取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#ifndef WINDOWIDUTIL_H#define WINDOWIDUTIL_H#include&lt;QDebug&gt;#include &lt;X11/Xlib.h&gt;#include &lt;X11/Xatom.h&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;stdlib.h&gt;class WindowsMatchingPid{public: WindowsMatchingPid(Display *display, Window wRoot, unsigned long pid) : _display(display), _pid(pid) { // Get the PID property atom. _atomPID = XInternAtom(display, \"_NET_WM_PID\", True); if(_atomPID == None) { std::cout &lt;&lt; \"No such atom\" &lt;&lt; std::endl; return; } search(wRoot); } const std::list&lt;Window&gt; &amp;result() const { return _result; }private: unsigned long _pid; Atom _atomPID; Display *_display; std::list&lt;Window&gt; _result; void search(Window w) { // Get the PID for the current Window. Atom type; int format; unsigned long nItems; unsigned long bytesAfter; unsigned char *propPID = 0; if(Success == XGetWindowProperty( _display, w, _atomPID, 0, 1, False, XA_CARDINAL, &amp;type, &amp;format, &amp;nItems, &amp;bytesAfter, &amp;propPID)) { if(propPID != 0) { // If the PID matches, add this window to the result set. if(_pid == *((unsigned long *)propPID)) { _result.push_back(w); } XFree(propPID); } } // Recurse into child windows. Window wRoot; Window wParent; Window *wChild; unsigned nChildren; if(0 != XQueryTree(_display, w, &amp;wRoot, &amp;wParent, &amp;wChild, &amp;nChildren)) { for(unsigned i = 0; i &lt; nChildren; i++) search(wChild[i]); } //XFree(propPID); }};unsigned longget_win_id_from_pid(qint64 pid){ //std::cout &lt;&lt; \"Searching for windows associated with PID \" &lt;&lt; pid &lt;&lt; std::endl; // Start with the root window. Display *display = XOpenDisplay(0); WindowsMatchingPid match(display, XDefaultRootWindow(display), pid); // Print the result. const std::list&lt;Window&gt; &amp;result = match.result(); long win_id = 0; for(std::list&lt;Window&gt;::const_iterator pos = result.begin(); pos != result.end(); pos++) { std::cout &lt;&lt; \"Window #\" &lt;&lt; (unsigned long)(*pos) &lt;&lt; std::endl; win_id = (unsigned long)(*pos); } return win_id;}#endif // WINDOWIDUTIL_H","link":"/2019/08/22/x-window-id/"},{"title":"Debian 10 设置 gnome-terminal 透明","text":"Debian 系列下设置gnome终端的透明度 Ubuntu 中可以通过图形化的方式设置 gnome-terminal 的透明度，但是在 Debian 系列中无法通过这种方式设置。查询了许多资料，发现可以在 shell脚本中通过 xprop 设置终端的透明度，如 ~/.bashrc 等。 代码如下： 1234567TRANSPARENCY_HEX=$(printf 0x%x $((0xffffffff * 70 / 100)))if [ -n \"$WINDOWID\" ]; then xprop -id \"$WINDOWID\" -f _NET_WM_WINDOW_OPACITY 32c -set _NET_WM_WINDOW_OPACITY \"$TRANSPARENCY_HEX\"else windowid=$(xprop -root | grep \"_NET_ACTIVE_WINDOW(WINDOW)\" | cut -d ' ' -f 5) xprop -id \"$windowid\" -f _NET_WM_WINDOW_OPACITY 32c -set _NET_WM_WINDOW_OPACITY \"$TRANSPARENCY_HEX\"fi 通过调整 TRANSPARENCT_HEX 中的值可以调整透明度。","link":"/2019/08/22/gnome-terminal-transparency/"},{"title":"8086 寄存器介绍","text":"本篇介绍 8086 CPU 寄存器的相关信息 8086 CPU 寄存器: (14个)八个通用寄存器AX: 累加寄存器 CX: 计数寄存器 DX: 数据寄存器 BX: 基址寄存器 BP: 基址指针寄存器 SI: 源变址寄存器 DI: 目的变址寄存器 SP: 堆栈指示寄存器，用来存放栈顶有效地址两个控制寄存器IP: 指令寄存器，用来存放下一条要取指令的有效地址 FL: 标志寄存器，用来存放状态标志和控制标志四个段寄存器 (用于存放段地址)DS: 数据段寄存器 (Data Segment) SS: 堆栈段寄存器 (Stack Segment) CS: 代码段寄存器 (Code Segment) ES: 附加段寄存器 (Extra Segment)","link":"/2018/10/05/register/"}],"tags":[{"name":"Assembly","slug":"Assembly","link":"/tags/Assembly/"},{"name":"Design-Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"},{"name":"UNIX","slug":"UNIX","link":"/tags/UNIX/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"MCU","slug":"MCU","link":"/tags/MCU/"},{"name":"Register","slug":"Register","link":"/tags/Register/"}],"categories":[{"name":"汇编","slug":"ASSEMBLY","link":"/categories/ASSEMBLY/"},{"name":"设计模式","slug":"DESIGN-PATTERN","link":"/categories/DESIGN-PATTERN/"},{"name":"UNIX环境高级编程","slug":"APUE","link":"/categories/APUE/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"单片机","slug":"MCU","link":"/categories/MCU/"}]}